""" Author: @kramiikk """

import asyncio
import logging
from datetime import datetime
from collections import deque
from typing import Optional, Dict, Union
from telethon import functions, types, errors
from telethon.errors.rpcerrorlist import (
    MessageIdInvalidError,
    PhotoInvalidDimensionsError,
    PhotoCropSizeSmallError,
    PhotoSaveFileInvalidError,
)
from .. import loader, utils
import json

logger = logging.getLogger(__name__)


@loader.tds
class ProfileChangerMod(loader.Module):
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è —Å –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π –∑–∞—â–∏—Ç—ã"""

    strings = {
        "name": "ProfileChanger",
        "starting": "üîÑ <b>–ó–∞–ø—É—Å–∫ —Å–º–µ–Ω—ã —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è</b>\n\n‚Ä¢ –ó–∞–¥–µ—Ä–∂–∫–∞: {delay_minutes:.1f} –º–∏–Ω\n‚Ä¢ ~{updates_per_hour} –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π/—á–∞—Å",
        "stopping": "üõë <b>–û—Å—Ç–∞–Ω–æ–≤–∫–∞</b>\n\n‚Ä¢ –û–±–Ω–æ–≤–ª–µ–Ω–∏–π: {count}\n‚Ä¢ –í—Ä–µ–º—è: {uptime}\n‚Ä¢ –û—à–∏–±–æ–∫: {errors}",
        "stats": "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>\n\n‚Ä¢ –°—Ç–∞—Ç—É—Å: {status}\n‚Ä¢ –í—Ä–µ–º—è: {uptime}\n‚Ä¢ –û–±–Ω–æ–≤–ª–µ–Ω–∏–π: {count}\n‚Ä¢ –í —á–∞—Å: {hourly}\n‚Ä¢ –ó–∞–¥–µ—Ä–∂–∫–∞: {delay:.1f} –º–∏–Ω\n‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω–µ–µ: {last}\n‚Ä¢ –û—à–∏–±–æ–∫: {errors}\n‚Ä¢ –§–ª—É–¥–≤–µ–π—Ç–æ–≤: {floods}",
        "no_photo": "‚ùå <b>–û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Ñ–æ—Ç–æ</b>",
        "already_running": "‚ö†Ô∏è <b>–£–∂–µ –∑–∞–ø—É—â–µ–Ω–æ</b>",
        "not_running": "‚ö†Ô∏è <b>–ù–µ –∑–∞–ø—É—â–µ–Ω–æ</b>",
        "error": "‚ùå <b>–û—à–∏–±–∫–∞:</b> {error}",
        "flood_wait": "‚ö†Ô∏è <b>–§–ª—É–¥–≤–µ–π—Ç</b>\n\n‚Ä¢ –ù–æ–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞: {delay:.1f} –º–∏–Ω\n‚Ä¢ –û–∂–∏–¥–∞–Ω–∏–µ: {wait:.1f} –º–∏–Ω",
        "photo_invalid": "‚ö†Ô∏è <b>–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–æ—Ç–æ:</b> {error}",
        "pfpone_success": "‚úÖ <b>–ê–≤–∞—Ç–∞—Ä–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞</b>",
        "pfpone_no_reply": "‚ùå <b>–û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Ñ–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</b>",
        "pfpone_error": "‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –∞–≤–∞—Ç–∞—Ä–∫–∏:</b> {error}",
    }

    _state_keys = [
        "running",
        "start_time",
        "last_update",
        "update_count",
        "error_count",
        "flood_count",
        "delay",
        "chat_id",
        "message_id",
        "success_streak",
        "floods",
        "retries",
    ]

    def __init__(self):
        self.config = loader.ModuleConfig(
            "adaptive_delay",
            True,
            "–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–µ—Ä–∂–∫–∏",
            "notify_errors",
            True,
            "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö",
            "default_delay",
            780,
            "–ù–∞—á–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ (—Å–µ–∫)",
            "min_delay",
            420,
            "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ (—Å–µ–∫)",
            "max_delay",
            1980,
            "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ (—Å–µ–∫)",
            "jitter",
            0.3,
            "–°–ª—É—á–∞–π–Ω–æ—Å—Ç—å (0.0-1.0)",
            "error_threshold",
            2,
            "–ü–æ—Ä–æ–≥ –æ—à–∏–±–æ–∫",
            "flood_multiplier",
            1.2,
            "–ú–Ω–æ–∂–∏—Ç–µ–ª—å —Ñ–ª—É–¥–≤–µ–π—Ç–∞",
            "success_reduction",
            0.9,
            "–°–Ω–∏–∂–µ–Ω–∏–µ –ø—Ä–∏ —É—Å–ø–µ—Ö–µ",
            "error_penalty",
            1.1,
        )
        self._reset()

    def _reset(self) -> None:
        """–°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        self.running = False
        self._task = None
        self.start_time = None
        self.last_update = None
        self.update_count = 0
        self.error_count = 0
        self.flood_count = 0
        self.delay = self.config["default_delay"]
        self.chat_id = None
        self.message_id = None
        self.floods = deque(maxlen=10)
        self.success_streak = 0
        self._retries = 0
        self._lock = asyncio.Lock()
        self._last_command_time = None

    async def client_ready(self, client, db):
        self._client = client
        self._db = db
        self._me = await client.get_me()
        self._load_state()
        if self.running:
            self._task = asyncio.create_task(self._loop())
        logger.info("ProfileChanger loaded")

    async def on_unload(self):
        """–í—ã–≥—Ä—É–∑–∫–∞ –º–æ–¥—É–ª—è"""
        if self.running:
            await self._send_stopping_message()
            self._task.cancel()
        logger.info("ProfileChanger unloaded")

    def _get_state(self) -> Dict:
        state = {key: getattr(self, key) for key in self._state_keys}
        if state.get("start_time"):
            state["start_time"] = state["start_time"].isoformat()
        if state.get("last_update"):
            state["last_update"] = state["last_update"].isoformat()
        if state.get("floods"):
            state["floods"] = [t.isoformat() for t in state["floods"]]
        return state

    def _load_state(self) -> None:
        state_json = self._db.get(self.strings["name"], "state")
        if not state_json:
            return
        try:
            state = json.loads(state_json)
            for key, value in state.items():
                if key == "start_time" and value:
                    setattr(self, key, datetime.fromisoformat(value))
                elif key == "last_update" and value:
                    setattr(self, key, datetime.fromisoformat(value))
                elif key == "floods":
                    setattr(
                        self,
                        key,
                        deque([datetime.fromisoformat(t) for t in value], maxlen=10),
                    )
                else:
                    setattr(self, key, value)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è: {type(e).__name__}: {e}")
            self._reset()

    async def _get_photo(self) -> Optional[types.Photo]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–æ—Ç–æ"""
        if not self.running:
            return None
        try:
            message = await self._client.get_messages(self.chat_id, ids=self.message_id)
            if not message or not message.photo:
                await self._stop("—Ñ–æ—Ç–æ —É–¥–∞–ª–µ–Ω–æ")
                return None
            return message.photo
        except MessageIdInvalidError:
            await self._stop("—Ñ–æ—Ç–æ —É–¥–∞–ª–µ–Ω–æ")
            return None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–æ—Ç–æ: {e}")
            return None

    async def _set_profile_photo(
        self, photo: types.Photo
    ) -> Union[bool, errors.FloodWaitError, Exception]:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è"""
        try:
            await self._client(
                functions.photos.UpdateProfilePhotoRequest(
                    id=types.InputPhoto(
                        id=photo.id,
                        access_hash=photo.access_hash,
                        file_reference=photo.file_reference,
                    )
                )
            )
            return True
        except errors.FloodWaitError as e:
            return e
        except (
            PhotoInvalidDimensionsError,
            PhotoCropSizeSmallError,
            PhotoSaveFileInvalidError,
        ) as e:
            return e
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è: {e}")
            return e

    async def _handle_flood_wait(self, error: errors.FloodWaitError):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ FloodWaitError."""
        self.flood_count += 1
        self.floods.append(datetime.now())
        self.success_streak = 0
        self.delay = min(
            self.config["max_delay"], self.delay * self.config["flood_multiplier"]
        )
        if self.config["notify_errors"]:
            await self._client.send_message(
                self.chat_id,
                self.strings["flood_wait"].format(
                    delay=self.delay / 60, wait=error.seconds / 60
                ),
            )
        logger.warning(
            f"–ü–æ–ª—É—á–µ–Ω FloodWait: {error.seconds}s. –ù–æ–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞: {self.delay}s"
        )
        await asyncio.sleep(error.seconds)

    async def _handle_photo_invalid_error(self, error):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –Ω–µ–≤–µ—Ä–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ —Ñ–æ—Ç–æ."""
        self.error_count += 1
        if self.config["notify_errors"]:
            await self._client.send_message(
                self.chat_id,
                self.strings["photo_invalid"].format(error=str(error)),
            )
        await self._stop(f"–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–æ—Ç–æ: {error}")

    async def _handle_generic_error(self, error):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—â–∏—Ö –æ—à–∏–±–æ–∫ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–æ—Ç–æ."""
        self.error_count += 1
        self.success_streak = 0
        self._retries += 1
        if self.config["notify_errors"]:
            await self._client.send_message(
                self.chat_id, self.strings["error"].format(error=str(error))
            )
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–æ—Ç–æ: {error}")

    async def _process_set_photo_result(
        self, result: Union[bool, errors.FloodWaitError, Exception]
    ) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ _set_profile_photo."""
        if result is True:
            self.last_update = datetime.now()
            self.update_count += 1
            self.success_streak += 1
            self._retries = 0
            logger.info(
                f"–§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ. –í—Å–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: {self.update_count}"
            )
            return True
        elif isinstance(result, errors.FloodWaitError):
            await self._handle_flood_wait(result)
            return False
        elif isinstance(
            result,
            (
                PhotoInvalidDimensionsError,
                PhotoCropSizeSmallError,
                PhotoSaveFileInvalidError,
            ),
        ):
            await self._handle_photo_invalid_error(result)
            return False
        else:
            await self._handle_generic_error(result)
            return False

    async def _update(self) -> bool:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–æ—Ç–æ"""
        if not self.running:
            return False
        photo = await self._get_photo()
        if not photo:
            return False
        result = await self._set_profile_photo(photo)
        return await self._process_set_photo_result(result)

    def _calculate_delay(self) -> float:
        """–†–∞—Å—á–µ—Ç –∑–∞–¥–µ—Ä–∂–∫–∏"""
        if not self.config["adaptive_delay"]:
            return self.delay
        delay = self.delay

        now = datetime.now()
        while self.floods and (now - self.floods[0]).total_seconds() > 3600:
            self.floods.popleft()
        if self.success_streak >= 5:
            delay = max(
                self.config["min_delay"], delay * self.config["success_reduction"]
            )
        if self.floods:
            recent = len(self.floods)
            delay = min(
                self.config["max_delay"],
                delay * (self.config["flood_multiplier"] ** recent),
            )
        if self._retries > 0:
            delay *= self.config["error_penalty"]
        import random

        jitter = random.uniform(1 - self.config["jitter"], 1 + self.config["jitter"])
        return max(
            self.config["min_delay"], min(self.config["max_delay"], delay * jitter)
        )

    async def _loop(self) -> None:
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª"""
        while self.running:
            try:
                if await self._update():
                    await asyncio.sleep(self._calculate_delay())
                else:
                    if self._retries >= self.config["error_threshold"]:
                        await self._stop(
                            f"–ø—Ä–µ–≤—ã—à–µ–Ω –ø–æ—Ä–æ–≥ –æ—à–∏–±–æ–∫ ({self.config['error_threshold']})"
                        )
                        break
                    await asyncio.sleep(self.config["min_delay"])
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.exception(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: {e}")
                await asyncio.sleep(self.config["min_delay"])

    def _format_time(self, seconds: float) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏"""
        minutes, seconds = divmod(seconds, 60)
        hours, minutes = divmod(minutes, 60)
        if hours:
            return f"{int(hours)}—á {int(minutes)}–º"
        elif minutes:
            return f"{int(minutes)}–º {int(round(seconds))}—Å"
        return f"{int(round(seconds))}—Å"

    def _get_stats(self) -> Dict[str, str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        now = datetime.now()
        uptime = (now - self.start_time).total_seconds() if self.start_time else 0
        last = (now - self.last_update).total_seconds() if self.last_update else 0

        return {
            "status": "‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç" if self.running else "üõë –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
            "uptime": self._format_time(uptime),
            "count": str(self.update_count),
            "hourly": f"{self.update_count / (uptime/3600):.1f}" if uptime > 0 else "0",
            "delay": self.delay / 60,
            "last": self._format_time(last) if self.last_update else "–Ω–∏–∫–æ–≥–¥–∞",
            "errors": str(self.error_count),
            "floods": str(self.flood_count),
        }

    def _save_state(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        self._db.set(self.strings["name"], "state", json.dumps(self._get_state()))

    async def _start(self, chat_id: int, message_id: int) -> None:
        """–ó–∞–ø—É—Å–∫ —Å–º–µ–Ω—ã —Ñ–æ—Ç–æ"""
        self.running = True
        self.start_time = datetime.now()
        self.chat_id = chat_id
        self.message_id = message_id
        self._retries = 0
        self._save_state()
        self._task = asyncio.create_task(self._loop())
        logger.info("Profile changer started")

    async def _send_stopping_message(self):
        await self._client.send_message(
            self.chat_id,
            self.strings["stopping"].format(
                count=self.update_count,
                uptime=(
                    self._format_time(
                        (datetime.now() - self.start_time).total_seconds()
                    )
                    if self.start_time
                    else "0—Å"
                ),
                errors=self.error_count,
            ),
        )

    async def _stop(self, reason: Optional[str] = None) -> None:
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–º–µ–Ω—ã —Ñ–æ—Ç–æ"""
        if self.running:
            self.running = False
            self._save_state()
            if self._task:
                self._task.cancel()
            await self._send_stopping_message()
            logger.info(f"Profile changer stopped. {reason if reason else ''}")
            self._reset()

    @loader.command()
    async def pfp(self, message):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–º–µ–Ω—É —Ñ–æ—Ç–æ (–æ—Ç–≤–µ—Ç –Ω–∞ —Ñ–æ—Ç–æ)"""
        async with self._lock:
            if self.running:
                await utils.answer(message, self.strings["already_running"])
                return
            target = await message.get_reply_message() if message.is_reply else message
            photo_entity = target.photo if target else None

            if not photo_entity:
                await utils.answer(message, self.strings["no_photo"])
                return
            await self._start(message.chat_id, target.id)
            await utils.answer(
                message,
                self.strings["starting"].format(
                    delay_minutes=self.delay / 60,
                    updates_per_hour=round(3600 / self.delay),
                ),
            )

    @loader.command()
    async def pfpstop(self, message):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–º–µ–Ω—É —Ñ–æ—Ç–æ"""
        async with self._lock:
            if not self.running:
                await utils.answer(message, self.strings["not_running"])
                return
            await self._stop("–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")

    @loader.command()
    async def pfpstats(self, message):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        await utils.answer(message, self.strings["stats"].format(**self._get_stats()))

    @loader.command()
    async def pfpdelay(self, message):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ: .pfpdelay <—Å–µ–∫—É–Ω–¥—ã>)"""
        args = utils.get_args_raw(message)

        if not args:
            return await utils.answer(
                message, "–£–∫–∞–∂–∏—Ç–µ –∑–∞–¥–µ—Ä–∂–∫—É –≤ —Å–µ–∫—É–Ω–¥–∞—Ö –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã."
            )
        try:
            delay = float(args)
            if delay < self.config["min_delay"] or delay > self.config["max_delay"]:
                return await utils.answer(
                    message,
                    f"–ó–∞–¥–µ—Ä–∂–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç {self.config['min_delay']} –¥–æ {self.config['max_delay']} —Å–µ–∫—É–Ω–¥",
                )
            self.delay = delay
            self._save_state()
            await utils.answer(message, f"‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∑–∞–¥–µ—Ä–∂–∫–∞ {delay} —Å–µ–∫—É–Ω–¥")
        except ValueError:
            await utils.answer(message, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —á–∏—Å–ª–∞")

    @loader.command()
    async def pfpon(self, message):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤–∞—Ç–∞—Ä–∫—É –æ–¥–∏–Ω —Ä–∞–∑ (–æ—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Ñ–æ—Ç–æ)"""
        reply = await message.get_reply_message()
        if not reply or not reply.photo:
            await utils.answer(message, self.strings["pfpone_no_reply"])
            return
        photo = reply.photo
        result = await self._set_profile_photo(photo)
        await self._process_set_photo_result(result)
